# Implementation Plan: Todo Console App - Phase I

**Branch**: `001-todo-console-app` | **Date**: 2025-12-07 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/sp.plan` command with architectural decisions

## Summary

A single-file command-line todo manager built with Python 3.13+ standard library only. The application provides a menu-driven interface with 6 options for adding, viewing, updating, completing, and deleting tasks. All data is stored in-memory using a Python list, ensuring no persistence between sessions. The implementation follows spec-driven development principles with all code generated from specifications.

## Technical Context

**Language/Version**: Python 3.13+ (standard library only, no pip packages)
**Primary Dependencies**: None (standard library only)
**Storage**: In-memory Python list (`tasks = []`), data lost on exit
**Testing**: Manual verification via CLI; no test framework required
**Target Platform**: Any system with Python 3.13+ interpreter (Linux, macOS, Windows)
**Project Type**: Single-file CLI application
**Performance Goals**: Instant response times (<100ms), minimal memory footprint
**Constraints**: Single file at `src/main.py`, 1-200 char titles, 0-1000 char descriptions
**Scale/Scope**: Single user, in-memory session (typically <100 tasks per session)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Constitution Rule | Status | Evidence |
|-------------------|--------|----------|
| Simplicity First - single responsibility functions | PASS | Each operation (add, view, update, delete, toggle) has dedicated function |
| Spec-Driven Development - code from specs | PASS | All code generated by Claude Code from specifications |
| User-Centric Design - clear prompts and feedback | PASS | Confirmation messages for all operations, delete has confirmation |
| Python 3.13+ standard library only | PASS | No external dependencies |
| Single file: `src/main.py` | PASS | All code in one file |
| Functions: snake_case naming | PASS | e.g., `add_task`, `view_tasks`, `get_int_input` |
| Task structure with id, title, description, completed | PASS | Dict format specified in constitution |
| Docstrings for all functions | PASS | Required by Code Standards section |
| No crashes on invalid input | PASS | Input validation and error handling required |

## Project Structure

### Documentation (this feature)

```text
specs/001-todo-console-app/
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (skipped - no clarifications needed)
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output (skipped - no API contracts for CLI)
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
src/
└── main.py              # Single-file application (200-300 lines expected)

tests/                   # No formal tests - manual CLI verification per success criteria
```

**Structure Decision**: Single-file application at `src/main.py` with no additional directories. This aligns with the Phase I constraints and keeps the project simple for hackathon evaluation.

## Complexity Tracking

*Not applicable - no Constitution Check violations*

## Architectural Decisions

### AD-001: Data Structure - List of Dictionaries

**Decision**: Store tasks as a list of dictionaries: `[{"id": 1, "title": "...", "description": "...", "completed": False}, ...]`

**Rationale**:
- Simpler iteration for `view_tasks()` - natural for loop over list
- Natural ordering preserves insertion order for display
- Straightforward append for `add_task()`
- Dictionary format matches Python conventions and constitution requirements

**Alternatives Considered**:
- Dictionary keyed by ID: `{1: {...}, 2: {...}}` - Rejected because iteration requires `.values()`, less natural for ordered display
- Custom class: `class Task:` - Over-engineering for Phase I, dict is sufficient

### AD-002: ID Management - Global Counter

**Decision**: Use a global `next_id = 1` counter that increments on each task addition

**Rationale**:
- Ensures IDs never reuse even after deletion (per requirements)
- Simpler logic than `max(IDs) + 1` calculation
- No edge cases when list is empty (always start at 1)

**Alternatives Considered**:
- Calculate from existing tasks: `max(task["id"] for task in tasks) + 1` - Rejected because deleted IDs would be reused, violating requirements

### AD-003: Input Validation - Helper Functions

**Decision**: Create `get_int_input()` and `get_string_input()` helper functions

**Rationale**:
- DRY principle - validation logic in one place
- Consistent error messages across all operations
- Easier to test validation logic independently
- Cleaner operation functions that focus on business logic

**Alternatives Considered**:
- Inline validation: Rejected due to code duplication and inconsistent error handling

### AD-004: Delete Confirmation - Two-Step Process

**Decision**: Ask for task ID, then prompt for confirmation (y/n) before deletion

**Rationale**:
- Prevents accidental deletion of wrong task
- Matches user expectations from other applications
- Follows best practices for destructive operations
- Confirmation message clearly states which task will be deleted

**Alternatives Considered**:
- Immediate deletion: Rejected - too risky for accidental data loss

## Implementation Phases

### Phase 1: Foundation (Globals, Helpers, Menu Skeleton)

**Goal**: Establish code structure and basic menu loop

**Deliverables**:
- Global `tasks = []` list
- Global `next_id = 1` counter
- `display_menu()` function
- `main_menu()` loop function
- `main()` entry point

**Test**: Menu displays and loops properly, exits cleanly on option 6

### Phase 2: Add + View Operations

**Goal**: Core task creation and display functionality

**Deliverables**:
- `get_string_input()` helper with validation
- `get_int_input()` helper with validation
- `find_task(task_id)` helper function
- `add_task()` operation function
- `view_tasks()` operation function

**Test**: Can add tasks and see them displayed correctly

### Phase 3: Complete Operation

**Goal**: Task status toggling

**Deliverables**:
- `format_status(completed)` helper function
- `toggle_complete()` operation function

**Test**: Can mark tasks complete and toggle them back to pending

### Phase 4: Update Operation

**Goal**: Task modification

**Deliverables**:
- `update_task()` operation function
- Preserve current values when user enters empty string

**Test**: Can modify task title and/or description

### Phase 5: Delete Operation

**Goal**: Task removal with confirmation

**Deliverables**:
- `delete_task()` operation function
- Confirmation prompt with task details
- Safe removal from list

**Test**: Can delete tasks with confirmation, task no longer appears in view

### Phase 6: Polish

**Goal**: Error handling, edge cases, documentation

**Deliverables**:
- All error messages are user-friendly
- Edge cases handled (empty list, invalid IDs, non-numeric input)
- All functions have docstrings
- Code follows Python conventions (snake_case, UPPER_CASE constants)

**Test**: All test scenarios from specification pass without crashes

## Testing Strategy

### Unit Tests (Per Function)

| Function | Test Cases |
|----------|------------|
| `add_task` | Empty title rejection, valid task creation, ID increment, optional description |
| `view_tasks` | Empty list message, single task display, multiple tasks ordering, status formatting |
| `update_task` | Invalid ID handling, empty input preserves current value, confirmation message |
| `delete_task` | Invalid ID handling, confirmation prompt, successful removal, list update |
| `toggle_complete` | Invalid ID handling, status toggle both directions, confirmation message |

### Integration Tests (User Journeys)

| Test | Flow |
|------|------|
| Test 1 | Add → View → Verify display |
| Test 2 | Add → Complete → View → Verify status change |
| Test 3 | Add → Update → View → Verify changes |
| Test 4 | Add → Delete (confirm) → View → Verify removal |
| Test 5 | Add multiple → Complete some → Delete one → View → Verify state |
| Test 6 | All invalid inputs → Verify no crashes |

### Edge Case Tests

- Operations on empty list (update, delete, complete non-existent ID)
- Maximum length inputs (200 char title, 1000 char description)
- Numeric edge cases (ID 0, negative IDs, very large numbers)
- Menu choice edge cases (0, 7, negative, letters)

## Data Flow Patterns

### Add Task
```
User input → Validate (get_string_input) → Create dict → Append to tasks → Increment next_id → Confirm
```

### View Tasks
```
Iterate tasks → Format each (status, ID, title, description) → Display all
```

### Update Task
```
Get ID → Find task (find_task) → Show current values → Get new values → Modify dict → Confirm
```

### Delete Task
```
Get ID → Find task → Show task details → Confirm (y/n) → Remove from tasks → Confirm
```

### Toggle Complete
```
Get ID → Find task → Toggle completed bool → Confirm
```

## Menu Structure

```
=== Todo Console App ===
1. Add Task
2. View Tasks
3. Update Task
4. Delete Task
5. Toggle Complete
6. Exit

Enter your choice (1-6):
```

## Code Organization (src/main.py)

```python
# Section 1: Global State
tasks = []
next_id = 1

# Section 2: Helper Functions
def get_string_input(prompt, min_len=1, max_len=None):
def get_int_input(prompt, min_val=None, max_val=None):
def find_task(task_id):
def format_status(completed):

# Section 3: Operation Functions
def add_task():
def view_tasks():
def update_task():
def delete_task():
def toggle_complete():

# Section 4: Menu System
def display_menu():
def main_menu():

# Section 5: Entry Point
def main():
    main_menu()

if __name__ == "__main__":
    main()
```

## Success Criteria Alignment

| Success Criterion | Implementation Evidence |
|-------------------|------------------------|
| SC-001: Full lifecycle without crashes | All 5 operations tested, error handling prevents crashes |
| SC-002: 5 operations work correctly | Each operation function tested per unit tests |
| SC-003: Invalid inputs handled gracefully | get_int_input, get_string_input, find_task validate all inputs |
| SC-004: IDs auto-increment, never reuse | Global next_id counter, never reset on delete |
| SC-005: Menu loops until exit | main_menu() loop with break on choice 6 |
| SC-006: Clear confirmation messages | Each operation prints result before returning to menu |
| SC-007: Runs immediately with Python | Single file, no dependencies, `python src/main.py` |
